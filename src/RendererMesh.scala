//Copyright (c) 2013 Nathan Stoddard (nstodda@purdue.edu); see LICENSE.txt

package com.nathanstoddard.common.renderer
import com.nathanstoddard._

import scala.collection.mutable
import scala.language.implicitConversions

import org.lwjgl._
import org.lwjgl.opengl._
import org.lwjgl.input._
import org.lwjgl.opengl.GL11._
import org.lwjgl.opengl.GL12._
import org.lwjgl.opengl.GL13._
import org.lwjgl.opengl.GL15._
import org.lwjgl.opengl.GL20._
import org.lwjgl.opengl.GL21._

import org.newdawn.slick.{Color=>_, _}

import java.io._
import java.nio._
import java.awt.image._
import javax.imageio._

import common._
import common.log._
import common.geom._
import common.io._


/** A list of indices into a vertex array. Used by the mesh class. */
//TODO: make it easier to change only a part of the mesh
//TODO: store which mesh these MeshVerts are valid for - I commonly make the mistake of using MeshVerts from the wrong mesh!
class MeshVerts private[renderer](val indices:Array[MeshIndex]) {
  private[renderer] def this(indices:Array[Int]) = this(indices.map(MeshIndex(_)))
  def apply(i:Int):MeshIndex = indices(i)
  def apply(is:Int*):Array[MeshIndex] = is.map(indices(_)).toArray
  def head = indices.head
  def last = indices.last
  def reverse = new MeshVerts(indices.reverse)
  def ++(other:MeshVerts) = new MeshVerts(this.indices ++ other.indices)
  def +:(other:MeshIndex) = new MeshVerts(other +: this.indices)
  def line(a:Int, b:Int):(MeshIndex,MeshIndex) = (indices(a), indices(b))
  def lines(xs:(Int,Int)*):Array[(MeshIndex,MeshIndex)] = xs.map{case (a,b) => (indices(a), indices(b))}.toArray

  private def makeLineStrip(start:Int, end:Int):Array[(Int,Int)] = {
    val strip:Array[(Int,Int)] = new Array(end-start)
    for (i <- 0 until end-start) {
      strip(i) = (i+start, i+start+1)
    }
    strip
  }

  private def makeLineLoop(start:Int, end:Int):Array[(Int,Int)] = {
    Log.assert(end-start >= 2)
    val loop:Array[(Int,Int)] = new Array(end-start+1)
    for (i <- 0 to end-start) {
      loop(i) = (i+start, mod(i+1, end-start+1)+start)
    }
    loop
  }

  def size = indices.size

  //The endpoints of all these are inclusive
  def strip(start:Int, end:Int):Array[MeshIndex] = Array.range(start, end+1) map (indices(_))
  def lineStrip(start:Int, end:Int):Array[(MeshIndex,MeshIndex)] = makeLineStrip(start, end) map {case (a,b) => (indices(a), indices(b))}
  def loop(start:Int, end:Int):Array[MeshIndex] = (Array.range(start, end+1) :+ start) map (indices(_))
  def lineLoop(start:Int, end:Int):Array[(MeshIndex,MeshIndex)] = makeLineLoop(start, end) map {case (a,b) => (indices(a), indices(b))}

  def strip():Array[MeshIndex] = strip(0,indices.size-1)
  def lineStrip():Array[(MeshIndex,MeshIndex)] = lineStrip(0,indices.size-1)
  def loop():Array[MeshIndex] = loop(0,indices.size-1)
  def lineLoop():Array[(MeshIndex,MeshIndex)] = lineLoop(0,indices.size-1)
}
object MeshVerts {
  def apply(indices:MeshIndex*) = new MeshVerts(indices.toArray) //This is intended to be used by user code
  implicit def toStrip(verts:MeshVerts):Array[MeshIndex] = verts.strip
}


/** An index into a vertex array. Generated using a MeshVerts object, which is generated by a subclass of Mesh. */
//TODO: this is inaccurately named, since it also includes a vertex
case class MeshIndex private[renderer](private[renderer] val i:Int)


/** A mesh stores a collection of triangles and lines that can be rendered all at once.
  * It is inefficient to create but relatively efficient to render.
  */
abstract class Mesh(val program:GLProgram, val usage:VertexDataUsage) {
  protected val vertexBuilder = new mutable.ArrayBuilder.ofFloat
  protected val triangleBuilder = new mutable.ArrayBuilder.ofInt
  protected val lineBuilder = new mutable.ArrayBuilder.ofInt
  protected val pointBuilder = new mutable.ArrayBuilder.ofInt
  protected var numVertices = 0
  protected var numTriangleElems = 0
  protected var numLineElems = 0
  protected var numPointElems = 0
  protected var updated = false //TODO: this isn't disabled as often as it should be - it should be disabled every time the mesh is changed by adding a vertex, triangle, line, etc


  protected val vbo = glGenBuffers()
  protected val iboT = glGenBuffers()
  protected val iboL = glGenBuffers()
  protected val iboP = glGenBuffers()

  atexit(()=>destroy())

  //Log(Debug, "Creating mesh with VBOs " + vbo + ", " + iboT + ", " + iboL + ", " + iboP)

  /** Removes all vertices and indices from the mesh. */
  def clear() {
    vertexBuilder.clear()
    triangleBuilder.clear()
    lineBuilder.clear()
    pointBuilder.clear()
    _allPolygons.clear()
    _allLines.clear()
    _allPoints.clear()
    numVertices = 0
    numTriangleElems = 0
    numLineElems = 0
    numPointElems = 0
    updated = false
  }
  private var destroyed = false
  def destroy() = if (!destroyed) {
    destroyed = true
    //Log(Debug, "Destroying mesh with VBOs " + vbo + ", " + iboT + ", " + iboL + ", " + iboP)
    glDeleteBuffers(iboT)
    glDeleteBuffers(iboL)
    glDeleteBuffers(iboP)
    glDeleteBuffers(vbo)
  }

  private def update() = if (!updated) {
    if (numVertices > 0) {
      Renderer.checkGLError("Mesh.update start")
      val vertexBuffer = Renderer.makeFloatBuffer(vertexBuilder.result)
      val triangleBuffer = Renderer.makeIntBuffer(triangleBuilder.result)
      val lineBuffer = Renderer.makeIntBuffer(lineBuilder.result)
      val pointBuffer = Renderer.makeIntBuffer(pointBuilder.result)
      glBindBuffer(GL_ARRAY_BUFFER, vbo)
      glBufferData(GL_ARRAY_BUFFER, vertexBuffer, usage.glConstant)
      if (numTriangleElems > 0) {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, iboT)
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, triangleBuffer, usage.glConstant)
      }
      if (numLineElems > 0) {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, iboL)
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, lineBuffer, usage.glConstant)
      }
      if (numPointElems > 0) {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, iboP)
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, pointBuffer, usage.glConstant)
      }
      vertexBuffer.clear()
      triangleBuffer.clear()
      lineBuffer.clear()
      pointBuffer.clear()
      Renderer.checkGLError("Mesh.update end")
    }
    else
      Log(Warn, "Updating empty mesh.")
    updated = true
  }

  protected final def _draw() = if (numVertices > 0) {
    update()
    glBindBuffer(GL_ARRAY_BUFFER, vbo)
    program.setVertexAttribPointers()

    if (numTriangleElems > 0) {
      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, iboT)
     glDrawElements(Triangles.glConstant, numTriangleElems, GL_UNSIGNED_INT, 0)
    }
    if (numLineElems > 0) {
      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, iboL)
      glDrawElements(Lines.glConstant, numLineElems, GL_UNSIGNED_INT, 0)
    }
    if (numPointElems > 0) {
      glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, iboP)
      glDrawElements(Points.glConstant, numPointElems, GL_UNSIGNED_INT, 0)
    }
  }

  protected final def _verts(xss:Seq[Seq[Real]]) = {
    val res = new MeshVerts(Array.range(numVertices, numVertices+xss.size))
    numVertices += xss.size
    for (xs <- xss; x <- xs) vertexBuilder += x.toFloat
    updated = false
    res
  }

  private var _allPolygons = new mutable.ArrayBuffer[Array[MeshIndex]]
  private var _allLines = new mutable.ArrayBuffer[(MeshIndex,MeshIndex)]
  private var _allPoints = new mutable.ArrayBuffer[MeshIndex]
  def allPolygons = _allPolygons.result
  def allLines = _allLines.result

  private def triangle(a:MeshIndex, b:MeshIndex, c:MeshIndex) {
    triangleBuilder += a.i
    triangleBuilder += b.i
    triangleBuilder += c.i
    numTriangleElems += 3
  }
  def line(a:MeshIndex, b:MeshIndex) {
    lineBuilder += a.i
    lineBuilder += b.i
    _allLines += ((a,b))
    numLineElems += 2
  }
  def lines(xs:Array[(MeshIndex,MeshIndex)]) = {
    xs.foreach(x => line(x._1, x._2))
    _allLines ++= xs
  }
  def lines(xs:Seq[(MeshIndex,MeshIndex)]) = {
    xs.foreach(x => line(x._1, x._2))
    _allLines ++= xs
  }
  def point(a:MeshIndex) {
    pointBuilder += a.i
    _allPoints += a
    numPointElems += 1
  }
  def points(xs:Array[MeshIndex]) = {
    xs.foreach(point(_))
    _allPoints ++= xs
  }
  def polygon(xs:Array[MeshIndex]) {
    for (i <- 1 until xs.size-1)
      triangle(xs(0), xs(i), xs(i+1))
    _allPolygons += xs
  }
  def polygon(xs:MeshIndex*) {
    for (i <- 1 until xs.size-1)
      triangle(xs(0), xs(i), xs(i+1))
    _allPolygons += xs.toArray
  }
  def polygons(xs:Array[MeshIndex]*) = {
    xs.foreach(polygon(_))
    _allPolygons ++= xs
  }
}
